\section{Analisi}

\subsection{Script e Configurazione dei Test}

Per gestire l'esecuzione di un vasto numero di test con configurazioni eterogenee, è stato implementato un processo automatizzato orchestrato dallo script \texttt{scripts/run.sh}. La sua esecuzione può essere suddivisa nelle seguenti fasi:

\begin{enumerate}
    \item \textbf{Inizializzazione e Pulizia:} La prima azione dello script è la preparazione dell'ambiente di esecuzione. Vengono rimossi i risultati di esecuzioni precedenti eliminando il contenuto delle directory \texttt{logs/ csv/ plots/ profiling/ bin/}, se in caso queste non dovessero esistere verranno create. Questo garantisce che ogni esecuzione parta da uno stato pulito e che i risultati non vengano contaminati da test precedenti.

    \item \textbf{Compilazione:} Viene compilato il codice sorgente presente nella directory \texttt{src/} usando \texttt{nvcc}. L'eseguibile risultante, \texttt{bin/main.out}, viene così aggiornato all'ultima versione del codice prima dell'avvio dei test.

    \item \textbf{Iterazione sui File di Configurazione:} Lo script itera su tutti i file con estensione \texttt{.csv} presenti nella directory \texttt{tests/}. Ciascun file definisce una famiglia di test; al suo interno, ogni riga (esclusa l'intestazione) specifica i parametri per una singola esecuzione.

    \item \textbf{Generazione e Sottomissione dei Job:} Per ogni riga di un file di configurazione, che rappresenta un singolo test, lo script esegue i seguenti passaggi:
          \begin{itemize}
              \item \textbf{Parsing dei Parametri:} I valori per \texttt{matrix\_size}, \texttt{n\_proc}, \texttt{n\_gpu}, \texttt{tile\_width}, \texttt{grid\_width} e \texttt{grid\_height} vengono estratti dalla riga corrente.
              \item \textbf{Creazione dello Script SLURM:} Viene generato dinamicamente uno script di sottomissione SLURM. Questo script contiene le direttive \texttt{\#SBATCH} necessarie per richiedere le risorse al cluster (nodi, task, GPU per task) e definire i file di output e di errore. Il comando di esecuzione principale è incapsulato da \texttt{nsys profile} per la profilazione, e l'eseguibile \texttt{bin/main.out} viene lanciato con i parametri specifici del test.
              \item \textbf{Sottomissione del Job:} Lo script SLURM appena creato viene sottomesso al gestore di code tramite il comando \texttt{sbatch}. L'ID del job restituito da SLURM viene catturato e memorizzato.
              \item \textbf{Gestione delle Dipendenze:} L'ID del job viene aggiunto a una lista di dipendenze che sarà utilizzata nella fase finale.
          \end{itemize}

    \item \textbf{Job di Analisi e Plotting:} Una volta che tutti i job di calcolo sono stati sottomessi, lo script genera un ultimo job SLURM. Questo job ha una dipendenza di tipo \texttt{afterok} da tutti i job sottomessi in precedenza. Ciò significa che verrà eseguito solo dopo che tutti i test di calcolo saranno terminati con successo. Il compito di questo job finale è eseguire lo script Python \texttt{scripts/plots.py}, che si occupa di aggregare i dati dai file \texttt{.csv} generati e di creare i grafici di performance.
\end{enumerate}

\subsection{Analisi delle misurazioni}
Purtroppo, a causa di problemi tecnici con la versione di OpenMPI presente sul cluster, non è stato possibile valutare in maniera significativa il programma. In particolare, la funzione usata per creare la griglia di processi\footnote{\url{https://docs.open-mpi.org/en/v5.0.x/man-openmpi/man3/MPI_Cart_create.3.html}} potrebbe fallire arbitrariamente causando la chiusura forzata dell'eseguibile. Sperimentazioni ausiliarie hanno portato eventualmente sempre allo stesso errore, il che fa presagire qualche problema in quella versione della libreria.

È stato deciso di eseguire dei test locali su una singola macchina, che ovviamente non saranno indicativi delle prestazioni reali ma utili comunque a ricavare qualche spunto di riflessione.
Sono stati eseguiti i seguenti test:
\begin{enumerate}
    \item al crescere del numero di processi e threads, con dimensione fissata
          \begin{enumerate}
              \item al crescere delle dimensioni della matrice, a parità di processi (4) e thread (1024);
              \item al crescere del numero di processi, a parità di thread (1024) e dimensioni della matrice ($2048 \times 2048$);
              \item al crescere del numero di thread per processo, a parità di processi (4) e dimensioni della matrice ($2048 \times 2048$);
          \end{enumerate}
    \item al crescere del numero di processi, a parità di thread ($1024 \times 1024$) e dimensione del problema per processo ($1024 \times 1024$);
    \item al crescere del numero di thread, a parità di processi (4) e dimensione del problema per thread;
    \item al crescere del numero di processi, a parità di thread (1024) e dimensione del problema per thread.
\end{enumerate}

\begin{table}[h]
    \centering
    \begin{tabular}{cc}
        \hline
        \textbf{Matrice}    & \textbf{Tempo (s)} \\ \hline
        $16   \times 16   $ & 0.000012           \\
        $32   \times 32   $ & 0.000087           \\
        $64   \times 64   $ & 0.000573           \\
        $128  \times 128  $ & 0.004766           \\
        $256  \times 256  $ & 0.036135           \\
        $512  \times 512  $ & 0.284944           \\
        $1024 \times 1024 $ & 2.281789           \\
        $2048 \times 2048 $ & 18.509902          \\
        $4096 \times 4096 $ & 151.839314         \\ \hline
    \end{tabular}
    \caption{Tempi di esecuzione algoritmo sequenziale}
\end{table}

\begin{table}[h]
    \centering
    \begin{tabular}{cc}
        \hline
        \textbf{Matrice}    & \textbf{Tempo (s)} \\ \hline
        $16   \times 16   $ & 0.000012           \\
        $32   \times 32   $ & 0.000087           \\
        $64   \times 64   $ & 0.000573           \\
        $128  \times 128  $ & 0.004766           \\
        $256  \times 256  $ & 0.036135           \\
        $512  \times 512  $ & 0.284944           \\
        $1024 \times 1024 $ & 2.281789           \\
        $2048 \times 2048 $ & 18.509902          \\
        $4096 \times 4096 $ & 151.839314         \\ \hline
    \end{tabular}
    \caption{Tempi di esecuzione cuBLAS}
\end{table}

\begin{table}[h]
    \centering
    \begin{tabular}{cccccc}
        \hline
        \textbf{Matrice}    & \textbf{Processi} & \textbf{Thread} & \textbf{Tempo (s)} & \textbf{Speedup} & \textbf{Efficienza} \\ \hline
        $16   \times 16   $ & 4                 & 1024            & 0.000012           & 50               & 0.001               \\
        $32   \times 32   $ & 4                 & 1024            & 0.000012           &                  & 0.001               \\
        $64   \times 64   $ & 4                 & 1024            & 0.000012           &                  & 0.001               \\
        $128  \times 128  $ & 4                 & 1024            & 0.000012           &                  & 0.001               \\
        $256  \times 256  $ & 4                 & 1024            & 0.000012           &                  & 0.001               \\
        $512  \times 512  $ & 4                 & 1024            & 0.000012           &                  & 0.001               \\
        $1024 \times 1024 $ & 4                 & 1024            & 0.000012           &                  & 0.001               \\
        $2048 \times 2048 $ & 4                 & 1024            & 0.000012           &                  & 0.001               \\
        $4096 \times 4096 $ & 4                 & 1024            & 0.000012           &                  & 0.001               \\ \hline
    \end{tabular}
    \caption{Metriche test 1a}
\end{table}

\begin{table}[h]
    \centering
    \begin{tabular}{cccccc}
        \hline
        \textbf{Matrice}   & \textbf{Processi} & \textbf{Thread} & \textbf{Tempo (s)} & \textbf{Speedup} & \textbf{Efficienza} \\ \hline
        $2048 \times 2048$ & 2                 & 1024            & 0.000012           & 50               & 0.001               \\
        $2048 \times 2048$ & 4                 & 1024            & 0.000012           &                  & 0.001               \\
        $2048 \times 2048$ & 8                 & 1024            & 0.000012           &                  & 0.001               \\
        $2048 \times 2048$ & 16                & 1024            & 0.000012           &                  & 0.001               \\ \hline
    \end{tabular}
    \caption{Metriche test 1b}
\end{table}

\begin{table}[h]
    \centering
    \begin{tabular}{cccccc}
        \hline
        \textbf{Matrice}   & \textbf{Processi} & \textbf{Thread} & \textbf{Tempo (s)} & \textbf{Speedup} & \textbf{Efficienza} \\ \hline
        $2048 \times 2048$ & 4                 & 256             & 0.000012           & 50               & 0.001               \\
        $2048 \times 2048$ & 4                 & 1024            & 0.000012           &                  & 0.001               \\
        $2048 \times 2048$ & 4                 & 4096            & 0.000012           &                  & 0.001               \\
        $2048 \times 2048$ & 4                 & 16384           & 0.000012           &                  & 0.001               \\ \hline
    \end{tabular}
    \caption{Metriche test 1c}
\end{table}

\begin{table}[h]
    \centering
    \begin{tabular}{cccccc}
        \hline
        \textbf{Matrice}    & \textbf{Processi} & \textbf{Thread} & \textbf{Tempo (s)} & \textbf{Speedup} & \textbf{Efficienza} \\ \hline
        $1024 \times 1024 $ & 1                 & 1024            & 0.287              & 50               & 0.001               \\
        $2048 \times 2048 $ & 4                 & 1024            & 2.211              & 50               & 0.001               \\
        $4096 \times 4096 $ & 16                & 1024            & 16.459             &                  & 0.001               \\ \hline
        %                     &                   &                    &                  &                     \\ \hline
        % \textbf{Matrice}    & \textbf{Processi} & \textbf{Tempo (s)} & \textbf{Speedup} & \textbf{Efficienza} \\ \hline
        % $1024 \times 1024 $ & 1                 & 0.040 s            & 50               & 0.001               \\
        % $2048 \times 2048 $ & 4                 & 0.278 s            & 50               & 0.001               \\
        % $4096 \times 4096 $ & 16                & 1.986 s            &                  & 0.001               \\ \hline
    \end{tabular}
    \caption{Metriche test b}
\end{table}

\begin{table}[h]
    \centering
    \begin{tabular}{cccccc}
        \hline
        \textbf{Matrice}    & \textbf{Processi} & \textbf{Thread} & \textbf{Tempo (s)} & \textbf{Speedup} & \textbf{Efficienza} \\ \hline
        $64 \times 64 $     & 4                 & 16              & 0.109685           & 50               & 0.001               \\
        $128 \times 128 $   & 4                 & 64              & 0.114456           & 50               & 0.001               \\
        $256 \times 256 $   & 4                 & 256             & 0.114456           & 50               & 0.001               \\
        $512 \times 512 $   & 4                 & 1024            & 0.114456           & 50               & 0.001               \\
        $1024 \times 1024 $ & 4                 & 4096            & 0.114456           & 50               & 0.001               \\
        $2048 \times 2048 $ & 4                 & 16384           & 0.111614           &                  & 0.001               \\ \hline
    \end{tabular}
    \caption{Metriche test c}
\end{table}

\begin{table}[h]
    \centering
    \begin{tabular}{cccccc}
        \hline
        \textbf{Matrice}    & \textbf{Processi} & \textbf{Thread} & \textbf{Tempo (s)} & \textbf{Speedup} & \textbf{Efficienza} \\ \hline
        $1024 \times 1024 $ & 1                 & 1024            & 0.109685           & 50               & 0.001               \\
        $2048 \times 2048 $ & 4                 & 1024            & 0.114456           & 50               & 0.001               \\
        $4096 \times 4096 $ & 16                & 1024            & 0.111614           &                  & 0.001               \\ \hline
    \end{tabular}
    \caption{Metriche test d}
\end{table}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_0.png}
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_0_speedup.png}
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_0_efficiency.png}
    \caption{Caso 1a}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_a1.png}
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_a1_speedup.png}
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_a1_efficiency.png}
    \caption{Caso 1b}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_a2.png}
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_a2_speedup.png}
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_a2_efficiency.png}
    \caption{Caso 1c}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_b.png}
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_b_speedup.png}
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_b_efficiency.png}
    \caption{Caso 2}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_c.png}
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_c_speedup.png}
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_c_efficiency.png}
    \caption{Caso 3}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_d.png}
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_d_speedup.png}
    \includegraphics[width=0.7\textwidth]{./imgs/graphs/caso_d_efficiency.png}
    \caption{Caso 4}
\end{figure}

Non è possibile trarre conclusioni certe date le limitazioni del caso ma un risultato ovvio è il miglioramento dei tempi di esecuzione grazie al parallelismo offerto dalle GPU.
In caso di un singolo nodo a parità di dimensioni della matrice, conviene aumentare il numero di thread usati dalla GPU piuttosto che distribuire il carico aumentando i processi. Ciò probabilmente è dovuto al fatto che i processi non riescono a utilizzare tutti contemporaneamente la GPU causando delle attese.

Un risultato leggermente preoccupante è l'efficienza praticamente nulla ottenuta dai vari test.

L'implementazione cuBLAS risulta, come prevedibile, molto ottimizzata e migliore della semplice implementazione presa in questione.

\subsection{NVIDIA Nsight Compute}

NVIDIA Nsight Compute è un profiler per CUDA che fornisce metriche dettagliate delle prestazioni e debug delle API tramite interfaccia utente e strumenti da riga di comando.
% TODO: che altro?

Purtroppo, a causa dei problemi tecnici riportati precedentemente, non è stato possibile valutare le metriche fornite da queste applicazioni.
